package ansipixels

import (
	"image"
	"image/color"
	"math"

	"fortio.org/safecast"
)

// HSLToRGB converts HSL values to RGB. h, s and l in [0,1].
// Initially from grol.io/grol/extensions images.go.
func HSLToRGB(h, s, l float64) color.NRGBA {
	var r, g, b float64

	if s == 0 {
		r, g, b = l, l, l
	} else {
		var q float64
		if l < 0.5 {
			q = l * (1. + s)
		} else {
			q = l + s - l*s
		}
		p := 2*l - q
		r = hueToRGB(p, q, h+1/3.)
		g = hueToRGB(p, q, h)
		b = hueToRGB(p, q, h-1/3.)
	}

	return color.NRGBA{
		R: uint8(math.Round(r * 255)),
		G: uint8(math.Round(g * 255)),
		B: uint8(math.Round(b * 255)),
		A: 255,
	}
}

func hueToRGB(p, q, t float64) float64 {
	if t < 0 {
		t += 1.
	}
	if t > 1 {
		t -= 1.
	}
	if t < 1/6. {
		return p + (q-p)*6*t
	}
	if t < 0.5 {
		return q
	}
	if t < 2/3. {
		return p + (q-p)*(2/3.-t)*6
	}
	return p
}

// Merge (additively) the pixel with alpha on top of the existing image.
func MergePlot(img *image.NRGBA, x, y int, c color.NRGBA, newalpha float64) {
	a := safecast.MustTruncate[uint8](float64(c.A) * newalpha)
	if newalpha == 0 {
		return // nothing to draw
	}

	p1 := img.NRGBAAt(x, y)
	if (p1.R == 0 && p1.G == 0 && p1.B == 0) || p1.A == 0 { // black below is no change
		img.SetNRGBA(x, y, color.NRGBA{c.R, c.G, c.B, a})
		return
	}
	/*
		p1.R = max(p1.R, c.R)
		p1.G = max(p1.G, c.G)
		p1.B = max(p1.B, c.B)
		p1.A = max(p1.A, a)
	*/
	// gosec unable to see the range checks with min/max. when it does we can drop mustconv.
	p1.R = safecast.MustConv[uint8](min(255, uint16(p1.R)+uint16(c.R)))
	p1.G = safecast.MustConv[uint8](min(255, uint16(p1.G)+uint16(c.G)))
	p1.B = safecast.MustConv[uint8](min(255, uint16(p1.B)+uint16(c.B)))
	// p1.A = uint8(min(255, uint16(p1.A)+uint16(p2.A))) // summing transparency yield non transparent quickly
	// p1.A = uint8(min(255, uint32(p1.A)*uint32(a))) // multiply transparency
	p1.A = safecast.MustConv[uint8](min(255, uint16(p1.A)+uint16(a))) // summing transparency - best for overlapping lines
	// p1.A = max(p1.A, a) //max of the two
	img.SetNRGBA(x, y, p1)
}

// Draw an anti-aliased line using Xiaolin Wu's algorithm.
// https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm
// This may or not be correct as it was mostly generated by our AI overlords.
func DrawAALine(img *image.NRGBA, x0, y0, x1, y1 float64, c color.NRGBA) {
	steep := math.Abs(y1-y0) > math.Abs(x1-x0)

	if steep {
		x0, y0 = y0, x0
		x1, y1 = y1, x1
	}

	if x0 > x1 {
		x0, x1 = x1, x0
		y0, y1 = y1, y0
	}

	dx := x1 - x0
	dy := y1 - y0
	gradient := dy / dx

	if dx == 0.0 {
		gradient = 1.0
	}

	// Handle first endpoint
	xEnd := math.Round(x0)
	yEnd := y0 + gradient*(xEnd-x0)
	xGap := 1 - frac(x0+0.5)
	xPixel1 := int(xEnd)
	yPixel1 := int(math.Floor(yEnd))

	if steep {
		MergePlot(img, yPixel1, xPixel1, c, (1-frac(yEnd))*xGap)
		MergePlot(img, yPixel1+1, xPixel1, c, frac(yEnd)*xGap)
	} else {
		MergePlot(img, xPixel1, yPixel1, c, (1-frac(yEnd))*xGap)
		MergePlot(img, xPixel1, yPixel1+1, c, frac(yEnd)*xGap)
	}

	intery := yEnd + gradient

	// Handle second endpoint
	xEnd = math.Round(x1)
	yEnd = y1 + gradient*(xEnd-x1)
	xGap = frac(x1 + 0.5)
	xPixel2 := int(xEnd)
	yPixel2 := int(math.Floor(yEnd))

	if steep {
		MergePlot(img, yPixel2, xPixel2, c, (1-frac(yEnd))*xGap)
		MergePlot(img, yPixel2+1, xPixel2, c, frac(yEnd)*xGap)
	} else {
		MergePlot(img, xPixel2, yPixel2, c, (1-frac(yEnd))*xGap)
		MergePlot(img, xPixel2, yPixel2+1, c, frac(yEnd)*xGap)
	}

	// Draw the main line
	if steep {
		for x := xPixel1 + 1; x < xPixel2; x++ {
			MergePlot(img, int(math.Floor(intery)), x, c, 1-frac(intery))
			MergePlot(img, int(math.Floor(intery))+1, x, c, frac(intery))
			intery += gradient
		}
	} else {
		for x := xPixel1 + 1; x < xPixel2; x++ {
			MergePlot(img, x, int(math.Floor(intery)), c, 1-frac(intery))
			MergePlot(img, x, int(math.Floor(intery))+1, c, frac(intery))
			intery += gradient
		}
	}
}

func frac(x float64) float64 {
	return x - math.Floor(x)
}

// Non aliased version.
// Brute force implementation of Bresenham's line algorithm.
func DrawLine(img *image.NRGBA, x0, y0, x1, y1 float64, c color.NRGBA) {
	// Convert float64 to int for pixel plotting
	x0i, y0i := int(math.Round(x0)), int(math.Round(y0))
	x1i, y1i := int(math.Round(x1)), int(math.Round(y1))

	steep := math.Abs(float64(y1i-y0i)) > math.Abs(float64(x1i-x0i))
	if steep {
		x0i, y0i = y0i, x0i
		x1i, y1i = y1i, x1i
	}

	if x0i > x1i {
		x0i, x1i = x1i, x0i
		y0i, y1i = y1i, y0i
	}

	dx := x1i - x0i
	dy := math.Abs(float64(y1i - y0i))
	err := float64(dx) / 2.0
	yStep := 1
	if y0i > y1i {
		yStep = -1
	}

	y := y0i
	for x := x0i; x <= x1i; x++ {
		if steep {
			img.SetNRGBA(y, x, c)
		} else {
			img.SetNRGBA(x, y, c)
		}
		err -= dy
		if err < 0 {
			y += yStep
			err += float64(dx)
		}
	}
}
